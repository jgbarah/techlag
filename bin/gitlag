#!/usr/bin/env python3
# -*- coding: utf-8 -*-

## Copyright (C) 2016 Bitergia
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 3 of the License, or
## (at your option) any later version.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
##
## Authors:
##   Jesus M. Gonzalez-Barahona <jgb@bitergia.com>
##

description = """
Compare a directory with a git repository to find the most likely checkout.

Assuming that a directory is similar to some checkout of a git repository,
compute metrics for comparing those checkouts with the directory, until
the most likely checkout (the one more similar to the directory) is found.

Example:

gitlag --repo git.repo -p git-2.7.0 --after 2016-02-01 \
    --ratio 5 --range 3 -gitcache git.repo.cache -l info

"""

import argparse
import logging
import tempfile
import techlag.gitlag
import datetime

def parse_args ():
    """
    Parse command line arguments

    """
    parser = argparse.ArgumentParser(description = description)
    parser.add_argument("-r", "--repo",
                        help = "Git repo to compare")
    parser.add_argument("-p", "--pkg",
                        help = "Source package to compare")
    parser.add_argument("-d", "--dpkg",
                        help = "Debian source package to compare (dsc file)")
    parser.add_argument("--debian_name", nargs='+',
                        help = "Debian source packages, (name and releases). Ex: git stretch/main lenny/main")
    parser.add_argument("--after", type=str,
                        help = "Consider only commits after date (eg: 2016-01-31)")
    parser.add_argument("--before", type=str,
                        help = "Consider only commits before date (eg: 2016-01-31)")
    parser.add_argument("-l", "--logging", type=str, choices=["info", "debug"],
                        help = "Logging level for output")
    parser.add_argument("--logfile", type=str,
                        help = "Log file")
    parser.add_argument("--ratio", type=int, default=5,
                        help = "Ratio to calculate steps in each iteration")
    parser.add_argument("--range", type=int, default=5,
                        help = "Number of computed commits in the range in each iteration")
    parser.add_argument("--gitcache", type=str, default=None,
                        help = "Cache for results of git log")
    args = parser.parse_args()
    return args

def lag (name, upstream, dir, after, store, ratio=10, range=3):
    """Compute technical lag for directory with respect to upstream repository.

    :param name:      name of package being computed
    :type name:       string
    :param upstream: upstream git repository Metainformation
    :type upstream:   techlag.gitlago.Repo
    :param dir:      path to directory (source code derived from upstream repo)
    :param after:    check only commits after this date, format: %Y-%m-%d
    :type after:      datetime.datetime
    :param ratio:     do approximation according to this ratio
    :param range:     do approximation according to this range
    :param store:    directory to store checkouts

    """

    # Create a Metrics object and compute the closest commit
    metrics = techlag.gitlag.Metrics(repo=upstream, dir=dir,
                                    metrics_kinds=['same'], store=store)
    commit = metrics.closest_commit (closest_fn=max, metric='common_lines',
                                    ratio=ratio, range=range,
                                    name=name)
    info_str = "{}: most similar upstream checkout is {} " \
        + "(diff: {}, date: {}, hash: {})."
    logging.info (info_str.format(
                            name, commit['sequence'], commit['diff'],
                            commit['date'], commit['hash']
                            ))
    logging.info ('Number of commits computed: ' + str(len(metrics.metrics)) \
                + " out of a total of " + str(metrics.last_commit_no()+1))
    # Compare the closest commit with the head (last commit)
    metrics_data = metrics.compare_checkouts (commit['sequence'],
                                            metrics.last_commit_no())
    logging.info ("Metrics comparing with last commit: " + str(metrics_data))
    metrics_data['diff_commits'] = metrics.last_commit_no() - commit['sequence']
    result_str = "{}: technical lag to master HEAD is " \
        + "{} (commits), {} (lines), {} (files)"
    print (result_str.format(name, metrics_data['diff_commits'],
                            metrics_data['common_lines'], metrics_data['common_files']),
            flush=True)

if __name__ == "__main__":
    args = parse_args()
    if args.logging:
        log_format = '%(levelname)s:%(message)s'
        if args.logging == "info":
            level = logging.INFO
        elif args.logging == "debug":
            level = logging.DEBUG
        if args.logfile:
            logging.basicConfig(format=log_format, level=level,
                                filename = args.logfile, filemode = "w")
        else:
            logging.basicConfig(format=log_format, level=level)

    if args.dpkg:
        dir = techlag.gitlag.extract_dpkg(args.dpkg)
    elif args.debian_name:
        pkg_name = args.debian_name[0]
        pkg_releases = args.debian_name[1:]
    else:
        pkg_releases = []

    if args.after:
        after = datetime.datetime.strptime(args.after, '%Y-%m-%d')
    else:
        after = None

    upstream = techlag.gitlag.Repo(url=args.repo, dir=args.repo,
                                    after=after, branches=['master'],
                                    cache=args.gitcache)

    store = tempfile.TemporaryDirectory()
    if len(pkg_releases) > 0:
        for pkg_release in pkg_releases:
            dsc_file = techlag.gitlag.get_dpkg(name=pkg_name, release=pkg_release, dir=store.name)
            dir = techlag.gitlag.extract_dpkg(dsc_file)
            lag(name=pkg_name+':'+pkg_release, upstream=upstream,
                dir=dir, after=after, steps=args.steps, range=args.range,
                store=store.name)
    else:
        dir = args.pkg
        lag (name=dir, upstream=upstream, dir=dir, after=after,
            ratio=args.ratio, range=args.range, store=store.name)
